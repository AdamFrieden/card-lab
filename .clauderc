# Card Lab - Project Context

## Project Overview
Card Lab is an experimental playground for building and fine-tuning card-based UI interactions with a focus on Framer Motion animations and React. The goal is to create polished, delightful micro-interactions that feel natural, weighted, and satisfying - optimized for a portrait mobile experience.

## Core Animation Principles

### 1. Natural, Weighted Movement
- **Easing Functions**: Use spring-based physics for authentic, weighty feel
- Current spring config: `stiffness: 300, damping: 20` (tunable via ConfigPanel)
- Avoid linear transitions - everything should feel like it has mass and momentum

### 2. Anticipation & Follow-Through
- Cards should "wind up" slightly before major movements (not yet implemented)
- Overshooting and settling into final positions creates satisfying feedback
- Spring physics naturally provides some of this behavior

### 3. Hover/Selection States
- **Scale**: Selected cards scale up (default 1.1x, tunable)
- **Lift**: Selected cards elevate with vertical translation (default -20px, tunable)
- **Depth**: Drop shadows and visual layering create z-axis depth
- **Breathing**: Gentle, continuous animations could enhance idle states (not yet implemented)

### 4. Staggered/Cascading Animations
- Multiple cards never animate simultaneously in lockstep
- **Stagger delay**: Default 0.05s between cards (tunable)
- Creates organic, ripple-like effect for groups
- Currently applied to: initial card hand entrance, slot list entrance

### 5. Impact Moments (Future)
- Particle effects for significant actions (not yet implemented)
- Screen shake for dramatic moments (not yet implemented)
- Exaggerated scaling for celebratory feedback (not yet implemented)

## Current Architecture

### Component Structure
```
App.tsx                 - Root component, state management, orchestration
├── ConfigPanel.tsx     - Live animation parameter tuning (bottom sheet)
├── SlotList.tsx        - Roster/deck area (top of screen)
│   └── AnimatedCard    - Shared card component with layout animations
├── CardHand.tsx        - Collapsible hand of available cards (bottom drawer)
│   └── Card.tsx        - Wrapper for cards in hand
│       └── AnimatedCard - Shared card component
```

### State Management
**Simple useState-based state** (no Redux/Zustand needed for this POC):
- `cards`: Array of available cards in hand
- `slots`: Array of roster positions (can be empty or filled)
- `selectedCardId`: Currently selected card for rostering
- `previewSlotId`: Target slot being previewed
- `rosteringCardId`: Card currently animating to roster (for fade-out)
- `animationConfig`: Live-tunable animation parameters

### Key Animation Techniques

#### 1. FLIP Animations (The Foundation)

**FLIP = First, Last, Invert, Play** - The core technique for smooth layout transitions.

**What is FLIP?**
FLIP is a performance technique for animating layout changes. Instead of animating expensive CSS properties like `top`/`left`/`width`/`height`, we:
1. **First**: Measure element's initial position
2. **Last**: Apply state change (DOM updates instantly)
3. **Invert**: Calculate difference, apply inverse transform to make it look like it's still in the old position
4. **Play**: Animate transform back to identity (natural position)

**Why FLIP matters:**
- Animates transforms (GPU-accelerated) instead of layout (CPU-heavy)
- Works across container changes, responsive layouts, orientation changes
- No hardcoded coordinates - adapts to any screen size
- Framer Motion implements FLIP automatically via `layoutId`

**How we use FLIP in Card Lab:**

Cards move between hand ↔ slots using shared `layoutId`:
```tsx
// In CardHand.tsx
<AnimatedCard layoutId={`card-${card.id}`} />

// In SlotList.tsx (same card, different location)
<AnimatedCard layoutId={`card-${card.id}`} inSlot={true} />
```

When the card moves from hand to slot:
1. Card exists in hand with `layoutId="card-1"`
2. User rosters → state updates → card now exists in slot with same `layoutId="card-1"`
3. Framer Motion detects the move, measures both positions
4. FLIP animation automatically happens - card smoothly morphs from hand → slot
5. Spring physics applied via `transition={{ layout: transition }}`

**Critical FLIP Guidelines (Framer Motion):**

1. **One identity per layoutId (per render)**
   - **Never render two elements with the same `layoutId` in the same render pass**
   - Framer needs to see the element move between parents across renders (before/after snapshots)
   - Don't duplicate; allow Framer to reconcile the move across React commits
   - ❌ BAD: Rendering card in hand AND slot in the same render tree
   - ✅ GOOD: Card exists in exactly one location per render (Framer tracks position changes across renders)

2. **Avoid competing transforms during FLIP**
   - The element with `layoutId` should be the primary moving node
   - Avoid ancestor/wrapper animations that apply transform during the same transition
   - Wrappers are OK if they don't introduce competing transform/layout animations
   - **Practical test**: If the card "teleports" or "wobbles oddly," you're fighting transforms

3. **Avoid timer-based cleanup**
   - ❌ BAD: Using `setTimeout` to remove/restore elements after springs
   - Springs don't have reliable fixed durations (varies with config, device performance)
   - Rapid interactions (roster then immediately unroster) will break timer coordination
   - ✅ GOOD: Use `onLayoutAnimationComplete` callback if you need post-transition steps
   - ✅ BETTER: Design state so there's nothing to "clean up" via timers

4. **Avoid AnimatePresence for pure layoutId transitions**
   - **Don't wrap shared `layoutId` transitions in `AnimatePresence`**
   - `AnimatePresence` waits for exit animations before re-layout → causes delays
   - Symptoms: Hand waits to shift after rostering, flashing during unrostering
   - ✅ GOOD: Direct map without `AnimatePresence` for FLIP transitions
   - ❌ BAD: `<AnimatePresence>{cards.map(...)}</AnimatePresence>` when using `layoutId`
   - Only use `AnimatePresence` for elements WITHOUT `layoutId` that need enter/exit animations

**Example: Proper FLIP Setup**
```tsx
// Keep one canonical card component rendered in exactly one container
// based on state, using layoutId on the card itself

// In render:
{cards.map((card) => {
  // Card is either in hand OR in slot, never both
  const isInSlot = slots.some(s => s.card?.id === card.id);

  if (isInSlot) return null; // Don't render in hand if in slot

  return (
    <AnimatedCard
      key={card.id}
      layoutId={`card-${card.id}`}
      card={card}
    />
  );
})}

{slots.map((slot) => {
  if (!slot.card) return <EmptySlot />;

  return (
    <AnimatedCard
      key={slot.card.id}
      layoutId={`card-${slot.card.id}`}
      card={slot.card}
      inSlot={true}
    />
  );
})}
```

**Common FLIP Mistakes to Avoid:**
- ❌ Double-rendering same `layoutId` in multiple locations in the same render pass
- ❌ Using `setTimeout` to coordinate FLIP cleanup (breaks with config changes, rapid clicks)
- ❌ Adding competing transform animations on wrapper elements during FLIP
- ❌ Wrapping `layoutId` elements in `AnimatePresence` (causes exit animation delays)
- ❌ Unmounting element before Framer can measure the transition (aggressively hiding too early)

**How Framer Motion FLIP Actually Works:**
1. React render N: Card exists in hand with `layoutId="card-1"` at position A
2. Framer measures and stores position A
3. State changes → React commits update
4. React render N+1: Card now exists in slot with same `layoutId="card-1"` at position B
5. Framer measures position B, calculates delta (B - A)
6. Framer applies inverse transform to make card appear at position A
7. Framer animates transform back to identity (natural position B)

The key: Framer needs to see the element in **both positions across two renders** (not simultaneously in one render).

#### 2. Unified Transition System

All animations use a centralized `createTransition()` helper:
```tsx
// utils/transitions.ts
export function createTransition(config: AnimationConfig): Transition {
  switch (config.transitionType) {
    case 'spring': return { type: 'spring', stiffness, damping };
    case 'tween': return { type: 'tween', duration, ease: 'easeInOut' };
    case 'bounce': return { type: 'spring', stiffness, damping: damping * 0.5 };
    case 'elastic': return { type: 'spring', stiffness: stiffness * 0.6, damping: damping * 0.4 };
  }
}
```

This ensures:
- Roster and un-roster animations are identical (mirrored)
- Config panel changes apply everywhere instantly
- Easy experimentation with different animation styles
- Consistent tuning of spring feel across interactions (layout snap, score pop, etc.)
- Works for both `transition={{ layout: ... }}` and `transition={...}` usage patterns

#### 3. AnimatePresence for Exit Animations
Wraps dynamic lists to allow exit animations:
- Cards entering/leaving the hand
- Slots showing/hiding based on fill state
- ConfigPanel enter/exit transitions
- Use `mode="popLayout"` only when exit animations interfere with layout measurements

#### 4. Stagger Delays
Applied to sequential elements for cascading effect:
```tsx
transition={{
  delay: index * animationConfig.staggerDelay,  // default: 0.05s
  ...transition,
}}
```

### Rostering Flow (Core Interaction)
1. User taps card → `selectedCardId` set, card scales/lifts
2. First empty slot becomes `previewSlotId` (shows preview state)
3. User taps "Roster Card" button
4. State updates (batched by React 18+ into single render):
   - `setCards()` removes card from hand
   - `setSlots()` adds card to target slot
   - Both updates batch → single render pass → card only in slot
5. Framer Motion sees `layoutId` moved from hand → slot across renders
6. FLIP animation happens automatically (measure, invert, play)
7. No timers, no intermediate states - FLIP handles everything
8. Selection cleared, ready for next interaction

**Unrostering Flow:**
1. User taps X button on rostered card
2. State updates (batched by React 18+ into single render):
   - `setSlots()` removes card from slot
   - `setCards()` adds card back to hand
   - Both updates batch → single render pass → card only in hand
3. Framer Motion sees `layoutId` moved from slot → hand across renders
4. FLIP animation happens automatically in reverse
5. Clean, simple, no coordination complexity

**React 18+ Automatic Batching:**
- Multiple `setState` calls in event handlers batch into single render
- This ensures card never exists in both locations in the same render tree
- Pre-React 18: Would need `ReactDOM.unstable_batchedUpdates()` or combined state

### Styling Approach
- **Mobile-first**: Portrait orientation, touch-optimized
- **Theme system**: Centralized design tokens with runtime theme switching
- **System fonts**: Native feel, better performance
- **Inline styles**: Components use theme values directly for dynamic theming
- **Flexbox layouts**: Responsive, minimal complexity

### Theme System Architecture

The app uses a lightweight TypeScript-based theme system that follows the same pattern as AnimationConfig:

**Structure:**
```
src/theme/
├── index.tsx           # ThemeProvider, useTheme() hook
├── types.ts            # Theme interface
├── defaultTheme.ts     # Purple theme (original)
├── utils.ts            # withOpacity(), hexToRgba(), createGradient()
└── themes/
    ├── blueTheme.ts    # Cool blue/cyan alternative
    └── woodlandTheme.ts # Earthy browns/greens
```

**How it works:**
1. **Theme interface** defines all design tokens (colors, spacing, typography, shadows, z-index)
2. **ThemeProvider** wraps app at root, provides current theme via React Context
3. **useTheme() hook** gives components access to theme values
4. **Helper functions** like `withOpacity(color, 0.5)` make dynamic colors easy
5. **Runtime switching** - change theme in ConfigPanel, entire app updates instantly

**Using themes in components:**
```tsx
import { useTheme, withOpacity } from '../theme';

function MyComponent() {
  const theme = useTheme();

  return (
    <div style={{
      background: theme.colors.brand.primaryGradient,
      padding: theme.spacing.lg,
      borderRadius: theme.radius.lg,
      boxShadow: theme.shadows.card,
      color: theme.colors.text.primary,
    }}>
      {/* Component content */}
    </div>
  );
}
```

**Key theme properties:**
- `colors.brand` - Primary/secondary gradients, accent colors
- `colors.background` - App, panel, card backgrounds
- `colors.text` - Primary/secondary/tertiary text colors
- `colors.overlay` - White transparency scale for glass effects
- `spacing` - xs(4px) → xxxl(40px) spacing scale
- `radius` - sm(6px) → circle(50%) border radius scale
- `shadows` - Card, button, glow, selected states
- `zIndex` - Layering system (card:1, hand:50, overlay:100)
- `typography` - Font sizes and weights
- `dimensions` - Card and pack dimensions

**Adding new themes:**
1. Create file in `src/theme/themes/yourTheme.ts`
2. Implement Theme interface with your color palette
3. Export from `src/theme/index.tsx`
4. Add to ConfigPanel theme selector

**Design philosophy:**
- Simple TypeScript objects (no CSS variables, no styled-components)
- Follows AnimationConfig pattern for consistency
- Inline styles in components for full theme control
- Helper functions abstract opacity/gradient logic
- Zero runtime cost - static theme objects

## Tunable Parameters (via ConfigPanel)

| Parameter | Default | Range | Effect |
|-----------|---------|-------|--------|
| cardScale | 1.1 | 1.0-1.5 | Scale multiplier when selected |
| cardLift | 20px | 0-50px | Vertical lift when selected |
| springStiffness | 300 | 50-500 | How "tight" springs feel |
| springDamping | 20 | 5-50 | How much springs bounce/overshoot |
| staggerDelay | 0.05s | 0-0.2s | Time between staggered animations |

Lower stiffness = slower, floatier
Lower damping = more bounce/overshoot
Higher stagger = more pronounced cascade effect

## Technology Stack
- **React 19.2.0**: Latest React with improved performance
- **Framer Motion 12.23.26**: Industry-standard animation library
- **TypeScript**: Type safety for animation configs and props
- **Vite**: Fast dev server, HMR for rapid iteration
- **CSS Modules**: Scoped styles per component (*.css files)

## File Naming Conventions
- Components: PascalCase (e.g., `CardHand.tsx`, `AnimatedCard.tsx`)
- Types: Shared in `types.ts`, exported interfaces
- Styles: Component-scoped (e.g., `CardHand.css` alongside `CardHand.tsx`)

## Development Philosophy
- **Iterate rapidly**: Hot reload, live config panel for instant feedback
- **Feel over perfection**: Prioritize how it feels, not strict timing accuracy
- **Mobile-first**: Design for touch, portrait, thumb-reachable zones
- **Start simple**: Add complexity only when needed for better feel
- **No premature optimization**: Focus on feel, measure performance later

## Future Enhancements (Not Yet Implemented)
- [ ] Anticipation: Cards wind up before flipping/moving
- [ ] Particle effects on roster success
- [ ] Screen shake on special moments
- [ ] Breathing/bobbing animations for idle cards
- [ ] Drag-and-drop instead of select-then-roster
- [ ] Custom easing functions (elastic, bounce)
- [ ] Sound effects (subtle whooshes, satisfying clicks)
- [ ] Haptic feedback for mobile devices
- [ ] Card flipping with 3D transforms
- [ ] Multiple card hands/decks
- [ ] Undo/redo roster actions

## Performance Optimizations

### GPU Acceleration
All animated cards include performance CSS properties:
```css
will-change: transform;
transform: translateZ(0);
backface-visibility: hidden;
-webkit-font-smoothing: antialiased;
```

These ensure:
- GPU compositing layer promotion
- Hardware-accelerated transforms
- Smoother rendering on mobile devices
- Prevention of text flickering during animations

### Framer Motion Optimizations
- **`layoutScroll: false`**: Disables scroll-based layout adjustments for better performance
- **`restDelta: 0.001` & `restSpeed: 0.001`**: Tighter spring settling thresholds for cleaner animation completion
- **Custom easing curves**: `[0.4, 0.0, 0.2, 1]` for tween mode (Material Design easing)
- **`transformStyle: 'preserve-3d'`**: Better 3D transform handling

### React Performance
- **`useCallback`**: Memoized event handlers prevent unnecessary re-renders during animations
- **`useMemo`**: Cached calculations (e.g., totalPower) avoid recalculation on every render
- **`AnimatePresence mode="popLayout"`**: Prioritizes layout animations, prevents exit animation interference

### Timing Considerations
- Default spring: `stiffness: 400, damping: 25` (snappier than original 300/20)
- Higher stiffness = faster, more responsive feel
- Higher damping = less overshoot, cleaner stops
- Balance between "juice" and control

## Visual Polish & Creative Techniques

### Shine Effects
Animated shine/gloss effects add premium feel to static surfaces:

```css
/* Animated diagonal shine sweep */
.shine {
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 30%,
    rgba(255, 255, 255, 0.3) 50%,
    transparent 70%
  );
  animation: shine 3s infinite;
}

@keyframes shine {
  0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
  100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
}
```

**Key principles:**
- Use on idle/static elements to add life and visual interest
- Oversized element (200% width/height) ensures full coverage during sweep
- Diagonal angle (45deg) feels more dynamic than horizontal/vertical
- Slower timing (3s) feels subtle and premium vs fast/gimmicky
- Lower opacity (0.3) for subtlety - don't overpower the base design

### Gradient Backgrounds
Rich gradients create depth and visual hierarchy:

```css
/* Multi-stop vibrant gradient */
background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);

/* Radial gradients for glow effects */
background: radial-gradient(
  circle at 50% 0%,
  rgba(255, 255, 255, 0.3),
  transparent 70%
);
```

**Guidelines:**
- 135deg diagonal creates natural flow vs flat 90deg/180deg
- Use vibrant colors for special moments (pack opening, rare cards)
- Layer multiple gradients (linear base + radial glow overlay)
- Keep alpha transparency for depth layering

### Particle Burst Effects
Explosion/burst particles for impact moments:

```tsx
{/* 12 particles in radial pattern */}
{[...Array(12)].map((_, i) => (
  <motion.div
    key={i}
    className="particle"
    initial={{ scale: 0, x: 0, y: 0 }}
    animate={{
      scale: [0, 1, 0],  // Grow then shrink
      x: Math.cos((i * 30 * Math.PI) / 180) * 150,
      y: Math.sin((i * 30 * Math.PI) / 180) * 150,
      opacity: [1, 1, 0],
    }}
    transition={{
      duration: 0.8,
      ease: 'easeOut',
    }}
  />
))}
```

**Pattern breakdown:**
- **Radial distribution**: `i * 30` gives 360° / 12 = 30° spacing
- **Polar to Cartesian**: `cos/sin` converts angle to x/y coordinates
- **Distance**: Multiply by radius (150px) for burst size
- **Scale animation**: `[0, 1, 0]` makes particles appear then disappear
- **Opacity fade**: `[1, 1, 0]` keeps visible during travel, fades at end

**When to use:**
- Pack opening moments
- Critical success events
- Celebratory feedback
- High-energy transitions

### Breathing/Hovering Animations
Gentle idle animations that suggest interactivity:

```tsx
<motion.div
  animate={{
    // Vertical hovering
    y: [0, -15, 0],
    // Subtle scale breathing
    scale: [1, 1.05, 1],
  }}
  transition={{
    duration: 2,
    repeat: Infinity,
    ease: 'easeInOut',
  }}
/>
```

**Best practices:**
- Use for idle/waiting states to add life
- Keep movement subtle (±15px, ±5% scale)
- Slow timing (2-3s) feels organic, not jittery
- `easeInOut` creates smooth acceleration/deceleration
- Infinite repeat for continuous ambient motion

### Glow & Drop Shadow Effects
Layered shadows create depth and highlight focus:

```css
/* Vibrant glow shadow */
box-shadow: 0 20px 60px rgba(240, 147, 251, 0.6);

/* Layered inner glow */
.glow {
  background: radial-gradient(
    circle at 50% 0%,
    rgba(255, 255, 255, 0.3),
    transparent 70%
  );
}
```

**Techniques:**
- Large blur radius (60px) for soft, diffused glow
- Match shadow color to element's gradient for cohesion
- Layer CSS `box-shadow` + gradient overlays for depth
- Higher opacity on hover/active states for feedback

### Multi-State Animation Patterns
State machines for complex sequential animations:

```tsx
type PackState = 'idle' | 'shaking' | 'opening' | 'opened';

const [packState, setPackState] = useState<PackState>('idle');

// Conditional animations based on state
animate={{
  scale: packState === 'opening'
    ? [1, 1.2, 0]  // Burst
    : packState === 'idle'
      ? [1, 1.05, 1]  // Breathing
      : 1,  // Default
  x: packState === 'shaking' ? [-10, 10, -10, 10, -5, 5, 0] : 0,
}}
```

**State flow design:**
1. `idle` → Breathing/hovering to show interactivity
2. `shaking` → Short, snappy pre-burst anticipation
3. `opening` → Dramatic burst/scale-out with particles
4. `opened` → Final revealed state

**Timing coordination:**
- Use `setTimeout` to sequence state transitions
- Match durations to animation completion
- Build anticipation with short pre-actions (shake before burst)

### Staggered Reveals
Sequential animations that build momentum:

```tsx
{cards.map((card, index) => (
  <motion.div
    initial={{ scale: 0, opacity: 0 }}
    animate={{ scale: 1, opacity: 1 }}
    transition={{
      delay: index * 0.15,  // 150ms stagger
      type: 'spring',
      stiffness: 300,
      damping: 30,
    }}
  />
))}
```

**Stagger timing:**
- 0.05-0.1s: Rapid cascade, energetic
- 0.15-0.2s: Deliberate, dramatic reveal
- 0.3s+: Slow burn, anticipation building

### Design Philosophy for Visual Effects
- **Layering**: Combine multiple subtle effects (gradient + glow + shine) for richness
- **Timing variation**: Mix fast snaps with slow drifts for rhythm
- **Color cohesion**: Match particle/shadow colors to base gradients
- **Anticipation**: Small pre-actions (shake, scale-down) before big moments
- **Exaggeration**: This is a lab - go 20% more dramatic than production
- **GPU-friendly**: Stick to transforms (scale, translate, rotate) and opacity
- **Purposeful motion**: Every animation should communicate state or invite interaction

## Notes for AI Assistants
- When adding animations, always use spring physics unless there's a specific reason not to
- Respect the tunable config - don't hardcode animation values
- Mobile interactions are primary - test touch targets and gestures
- Framer Motion's `layoutId` is the secret sauce for card movement - preserve it
- Keep the config panel accessible for quick experimentation
- Prioritize "juice" and feel over realistic simulation
- Don't be afraid to exaggerate - subtle is boring for a lab environment
- **Always include GPU acceleration CSS on animated elements**
- **Use `useCallback` for event handlers passed to animated children**
- **Avoid CSS transitions that conflict with Framer Motion animations**
- **Layer visual effects** (shine + gradient + glow) for premium polish
- **Use particle bursts sparingly** - save for high-impact moments
- **State machines** (idle → action → complete) create narrative flow
- **Breathing/hovering animations** make idle states feel alive
