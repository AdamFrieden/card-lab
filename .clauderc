# Card Lab - Project Context

## Project Overview
Card Lab is an experimental playground for building and fine-tuning card-based UI interactions with a focus on Framer Motion animations and React. The goal is to create polished, delightful micro-interactions that feel natural, weighted, and satisfying - optimized for a portrait mobile experience.

## Core Animation Principles

### 1. Natural, Weighted Movement
- **Easing Functions**: Use spring-based physics for authentic, weighty feel
- Current spring config: `stiffness: 300, damping: 20` (tunable via ConfigPanel)
- Avoid linear transitions - everything should feel like it has mass and momentum

### 2. Anticipation & Follow-Through
- Cards should "wind up" slightly before major movements (not yet implemented)
- Overshooting and settling into final positions creates satisfying feedback
- Spring physics naturally provides some of this behavior

### 3. Hover/Selection States
- **Scale**: Selected cards scale up (default 1.1x, tunable)
- **Lift**: Selected cards elevate with vertical translation (default -20px, tunable)
- **Depth**: Drop shadows and visual layering create z-axis depth
- **Breathing**: Gentle, continuous animations could enhance idle states (not yet implemented)

### 4. Staggered/Cascading Animations
- Multiple cards never animate simultaneously in lockstep
- **Stagger delay**: Default 0.05s between cards (tunable)
- Creates organic, ripple-like effect for groups
- Currently applied to: initial card hand entrance, slot list entrance

### 5. Impact Moments (Future)
- Particle effects for significant actions (not yet implemented)
- Screen shake for dramatic moments (not yet implemented)
- Exaggerated scaling for celebratory feedback (not yet implemented)

## Current Architecture

### Component Structure
```
App.tsx                 - Root component, state management, orchestration
├── ConfigPanel.tsx     - Live animation parameter tuning (bottom sheet)
├── SlotList.tsx        - Roster/deck area (top of screen)
│   └── AnimatedCard    - Shared card component with layout animations
├── CardHand.tsx        - Collapsible hand of available cards (bottom drawer)
│   └── Card.tsx        - Wrapper for cards in hand
│       └── AnimatedCard - Shared card component
```

### State Management
**Simple useState-based state** (no Redux/Zustand needed for this POC):
- `cards`: Array of available cards in hand
- `slots`: Array of roster positions (can be empty or filled)
- `selectedCardId`: Currently selected card for rostering
- `previewSlotId`: Target slot being previewed
- `rosteringCardId`: Card currently animating to roster (for fade-out)
- `animationConfig`: Live-tunable animation parameters

### Key Animation Techniques

#### 1. FLIP Animations (The Foundation)

**FLIP = First, Last, Invert, Play** - The core technique for smooth layout transitions.

**What is FLIP?**
FLIP is a performance technique for animating layout changes. Instead of animating expensive CSS properties like `top`/`left`/`width`/`height`, we:
1. **First**: Measure element's initial position
2. **Last**: Apply state change (DOM updates instantly)
3. **Invert**: Calculate difference, apply inverse transform to make it look like it's still in the old position
4. **Play**: Animate transform back to identity (natural position)

**Why FLIP matters:**
- Animates transforms (GPU-accelerated) instead of layout (CPU-heavy)
- Works across container changes, responsive layouts, orientation changes
- No hardcoded coordinates - adapts to any screen size
- Framer Motion implements FLIP automatically via `layoutId`

**How we use FLIP in Card Lab:**

Cards move between hand ↔ slots using shared `layoutId`:
```tsx
// In CardHand.tsx
<AnimatedCard layoutId={`card-${card.id}`} />

// In SlotList.tsx (same card, different location)
<AnimatedCard layoutId={`card-${card.id}`} inSlot={true} />
```

When the card moves from hand to slot:
1. Card exists in hand with `layoutId="card-1"`
2. User rosters → state updates → card now exists in slot with same `layoutId="card-1"`
3. Framer Motion detects the move, measures both positions
4. FLIP animation automatically happens - card smoothly morphs from hand → slot
5. Spring physics applied via `transition={{ layout: transition }}`

**Critical FLIP Guidelines (Framer Motion):**

1. **One identity per layoutId (per render)**
   - **Never render two elements with the same `layoutId` in the same render pass**
   - Framer needs to see the element move between parents across renders (before/after snapshots)
   - Don't duplicate; allow Framer to reconcile the move across React commits
   - ❌ BAD: Rendering card in hand AND slot in the same render tree
   - ✅ GOOD: Card exists in exactly one location per render (Framer tracks position changes across renders)

2. **Avoid competing transforms during FLIP**
   - The element with `layoutId` should be the primary moving node
   - Avoid ancestor/wrapper animations that apply transform during the same transition
   - Wrappers are OK if they don't introduce competing transform/layout animations
   - **Practical test**: If the card "teleports" or "wobbles oddly," you're fighting transforms

3. **Avoid timer-based cleanup**
   - ❌ BAD: Using `setTimeout` to remove/restore elements after springs
   - Springs don't have reliable fixed durations (varies with config, device performance)
   - Rapid interactions (roster then immediately unroster) will break timer coordination
   - ✅ GOOD: Use `onLayoutAnimationComplete` callback if you need post-transition steps
   - ✅ BETTER: Design state so there's nothing to "clean up" via timers

4. **Avoid AnimatePresence for pure layoutId transitions**
   - **Don't wrap shared `layoutId` transitions in `AnimatePresence`**
   - `AnimatePresence` waits for exit animations before re-layout → causes delays
   - Symptoms: Hand waits to shift after rostering, flashing during unrostering
   - ✅ GOOD: Direct map without `AnimatePresence` for FLIP transitions
   - ❌ BAD: `<AnimatePresence>{cards.map(...)}</AnimatePresence>` when using `layoutId`
   - Only use `AnimatePresence` for elements WITHOUT `layoutId` that need enter/exit animations

**Example: Proper FLIP Setup**
```tsx
// Keep one canonical card component rendered in exactly one container
// based on state, using layoutId on the card itself

// In render:
{cards.map((card) => {
  // Card is either in hand OR in slot, never both
  const isInSlot = slots.some(s => s.card?.id === card.id);

  if (isInSlot) return null; // Don't render in hand if in slot

  return (
    <AnimatedCard
      key={card.id}
      layoutId={`card-${card.id}`}
      card={card}
    />
  );
})}

{slots.map((slot) => {
  if (!slot.card) return <EmptySlot />;

  return (
    <AnimatedCard
      key={slot.card.id}
      layoutId={`card-${slot.card.id}`}
      card={slot.card}
      inSlot={true}
    />
  );
})}
```

**Common FLIP Mistakes to Avoid:**
- ❌ Double-rendering same `layoutId` in multiple locations in the same render pass
- ❌ Using `setTimeout` to coordinate FLIP cleanup (breaks with config changes, rapid clicks)
- ❌ Adding competing transform animations on wrapper elements during FLIP
- ❌ Wrapping `layoutId` elements in `AnimatePresence` (causes exit animation delays)
- ❌ Unmounting element before Framer can measure the transition (aggressively hiding too early)

**How Framer Motion FLIP Actually Works:**
1. React render N: Card exists in hand with `layoutId="card-1"` at position A
2. Framer measures and stores position A
3. State changes → React commits update
4. React render N+1: Card now exists in slot with same `layoutId="card-1"` at position B
5. Framer measures position B, calculates delta (B - A)
6. Framer applies inverse transform to make card appear at position A
7. Framer animates transform back to identity (natural position B)

The key: Framer needs to see the element in **both positions across two renders** (not simultaneously in one render).

#### 2. Unified Transition System

All animations use a centralized `createTransition()` helper:
```tsx
// utils/transitions.ts
export function createTransition(config: AnimationConfig): Transition {
  switch (config.transitionType) {
    case 'spring': return { type: 'spring', stiffness, damping };
    case 'tween': return { type: 'tween', duration, ease: 'easeInOut' };
    case 'bounce': return { type: 'spring', stiffness, damping: damping * 0.5 };
    case 'elastic': return { type: 'spring', stiffness: stiffness * 0.6, damping: damping * 0.4 };
  }
}
```

This ensures:
- Roster and un-roster animations are identical (mirrored)
- Config panel changes apply everywhere instantly
- Easy experimentation with different animation styles
- Consistent tuning of spring feel across interactions (layout snap, score pop, etc.)
- Works for both `transition={{ layout: ... }}` and `transition={...}` usage patterns

#### 3. AnimatePresence for Exit Animations
Wraps dynamic lists to allow exit animations:
- Cards entering/leaving the hand
- Slots showing/hiding based on fill state
- ConfigPanel enter/exit transitions
- Use `mode="popLayout"` only when exit animations interfere with layout measurements

#### 4. Stagger Delays
Applied to sequential elements for cascading effect:
```tsx
transition={{
  delay: index * animationConfig.staggerDelay,  // default: 0.05s
  ...transition,
}}
```

### Rostering Flow (Core Interaction)
1. User taps card → `selectedCardId` set, card scales/lifts
2. First empty slot becomes `previewSlotId` (shows preview state)
3. User taps "Roster Card" button
4. State updates (batched by React 18+ into single render):
   - `setCards()` removes card from hand
   - `setSlots()` adds card to target slot
   - Both updates batch → single render pass → card only in slot
5. Framer Motion sees `layoutId` moved from hand → slot across renders
6. FLIP animation happens automatically (measure, invert, play)
7. No timers, no intermediate states - FLIP handles everything
8. Selection cleared, ready for next interaction

**Unrostering Flow:**
1. User taps X button on rostered card
2. State updates (batched by React 18+ into single render):
   - `setSlots()` removes card from slot
   - `setCards()` adds card back to hand
   - Both updates batch → single render pass → card only in hand
3. Framer Motion sees `layoutId` moved from slot → hand across renders
4. FLIP animation happens automatically in reverse
5. Clean, simple, no coordination complexity

**React 18+ Automatic Batching:**
- Multiple `setState` calls in event handlers batch into single render
- This ensures card never exists in both locations in the same render tree
- Pre-React 18: Would need `ReactDOM.unstable_batchedUpdates()` or combined state

### Styling Approach
- **Mobile-first**: Portrait orientation, touch-optimized
- **Dark theme**: `#242424` background, high contrast text
- **System fonts**: Native feel, better performance
- **CSS custom properties**: Could be added for theming (not yet implemented)
- **Flexbox layouts**: Responsive, minimal complexity

## Tunable Parameters (via ConfigPanel)

| Parameter | Default | Range | Effect |
|-----------|---------|-------|--------|
| cardScale | 1.1 | 1.0-1.5 | Scale multiplier when selected |
| cardLift | 20px | 0-50px | Vertical lift when selected |
| springStiffness | 300 | 50-500 | How "tight" springs feel |
| springDamping | 20 | 5-50 | How much springs bounce/overshoot |
| staggerDelay | 0.05s | 0-0.2s | Time between staggered animations |

Lower stiffness = slower, floatier
Lower damping = more bounce/overshoot
Higher stagger = more pronounced cascade effect

## Technology Stack
- **React 19.2.0**: Latest React with improved performance
- **Framer Motion 12.23.26**: Industry-standard animation library
- **TypeScript**: Type safety for animation configs and props
- **Vite**: Fast dev server, HMR for rapid iteration
- **CSS Modules**: Scoped styles per component (*.css files)

## File Naming Conventions
- Components: PascalCase (e.g., `CardHand.tsx`, `AnimatedCard.tsx`)
- Types: Shared in `types.ts`, exported interfaces
- Styles: Component-scoped (e.g., `CardHand.css` alongside `CardHand.tsx`)

## Development Philosophy
- **Iterate rapidly**: Hot reload, live config panel for instant feedback
- **Feel over perfection**: Prioritize how it feels, not strict timing accuracy
- **Mobile-first**: Design for touch, portrait, thumb-reachable zones
- **Start simple**: Add complexity only when needed for better feel
- **No premature optimization**: Focus on feel, measure performance later

## Future Enhancements (Not Yet Implemented)
- [ ] Anticipation: Cards wind up before flipping/moving
- [ ] Particle effects on roster success
- [ ] Screen shake on special moments
- [ ] Breathing/bobbing animations for idle cards
- [ ] Drag-and-drop instead of select-then-roster
- [ ] Custom easing functions (elastic, bounce)
- [ ] Sound effects (subtle whooshes, satisfying clicks)
- [ ] Haptic feedback for mobile devices
- [ ] Card flipping with 3D transforms
- [ ] Multiple card hands/decks
- [ ] Undo/redo roster actions

## Performance Optimizations

### GPU Acceleration
All animated cards include performance CSS properties:
```css
will-change: transform;
transform: translateZ(0);
backface-visibility: hidden;
-webkit-font-smoothing: antialiased;
```

These ensure:
- GPU compositing layer promotion
- Hardware-accelerated transforms
- Smoother rendering on mobile devices
- Prevention of text flickering during animations

### Framer Motion Optimizations
- **`layoutScroll: false`**: Disables scroll-based layout adjustments for better performance
- **`restDelta: 0.001` & `restSpeed: 0.001`**: Tighter spring settling thresholds for cleaner animation completion
- **Custom easing curves**: `[0.4, 0.0, 0.2, 1]` for tween mode (Material Design easing)
- **`transformStyle: 'preserve-3d'`**: Better 3D transform handling

### React Performance
- **`useCallback`**: Memoized event handlers prevent unnecessary re-renders during animations
- **`useMemo`**: Cached calculations (e.g., totalPower) avoid recalculation on every render
- **`AnimatePresence mode="popLayout"`**: Prioritizes layout animations, prevents exit animation interference

### Timing Considerations
- Default spring: `stiffness: 400, damping: 25` (snappier than original 300/20)
- Higher stiffness = faster, more responsive feel
- Higher damping = less overshoot, cleaner stops
- Balance between "juice" and control

## Notes for AI Assistants
- When adding animations, always use spring physics unless there's a specific reason not to
- Respect the tunable config - don't hardcode animation values
- Mobile interactions are primary - test touch targets and gestures
- Framer Motion's `layoutId` is the secret sauce for card movement - preserve it
- Keep the config panel accessible for quick experimentation
- Prioritize "juice" and feel over realistic simulation
- Don't be afraid to exaggerate - subtle is boring for a lab environment
- **Always include GPU acceleration CSS on animated elements**
- **Use `useCallback` for event handlers passed to animated children**
- **Avoid CSS transitions that conflict with Framer Motion animations**
